import { Image } from '@teambit/docs.ui.zoomable-image';
import {
  StatusExample,
  StatusOutput,
  BitSnap,
  SnapExample,
  SnapOutput,
  BitTag,
  TagExample,
  TagOutput,
  BitReset,
  ResetExample,
  ResetOutput,
  CheckoutExample,
} from './commands';
import { ExpandedSnap, ExpandedTag, ExpandedReset } from './expand-command-options';
import changelog from './changelog.png';
import versionPicker from './version-picker.png';

# Snapping components

For a component to be independently collaborated on, it must maintain its own version history.
This history consists of _snaps_, which are the component's [immutable] recorded changes. Each snap records the state of the entire component including its source files, [dependencies](/getting-started/composing/use-dependencies), [configuration](/components/component-config), [metadata](/components/structure/component-metadata), and [build artifacts](/components/structure/component-artifacts).

Snaps are stored in the [local scope](/workspace/structure/local-scope) before they are exported to their [remote scopes](/getting-started/collaborate/remote-scope).

## Create a snap

Before you record your component's state, verify no issues are preventing it from being isolated from the workspace:

<StatusExample />

The output should display no issues. Note that this component is listed as 'new' as it haven't been snapped yet.

<StatusOutput />

Run the following to snap the latest component changes:

<SnapExample />

<ExpandedSnap />

The output lists the snapped component and the hash that points to that snap:

<SnapOutput />

The snap process includes a series of build tasks. The data and artifacts generated by these build tasks are persisted in that snap.
To learn more, see [Build pipelines](/dev-services/builder/build-pipelines).

To learn more about snaps, see [Snapping changes](/components/snaps).

## Create a tag (release version)

To record changes that represent a new release, create a snap that's tagged with a [sematic version](https://semver.org/):

<TagExample />

<ExpandedTag />

The output lists the snapped component and the semantic version that points to that snap.
Note that, when no information regarding the semantic version number is provided, the tag defaults to the next patch number (in this case `0.0.1`):

<TagOutput />

The tag process includes a series of build tasks. The data and artifacts generated by these build tasks are persisted in that snap.
To learn more, see [Build pipelines](/dev-services/builder/build-pipelines).

To learn more about tags, see [Tagging changes](/components/tags).

## Reset snaps

To reset snaps (that have not been exported yet), and revert a component to its previous state, run the following:

<ResetExample />

<ExpandedReset />

The output notifies that `apps/to-do` has been reset. Its tag version (`1.0.0`) has been removed (it is back to its status as 'new'):

<ResetOutput />

Note that 'reset' does not affect the component's source files in the workspace. To checkout the source files of a component after resetting, run:

<CheckoutExample />

## Review component history

With each component having it's own versioning and history you get a time-machine for components. You can see it in past working states, run diffs and even checkout a past version of a component to your workspace for maintenance.

<Image alt="changelog" src={changelog} />

And by running the `log` command:

```bash
bit log ui/my-welcome
```

Read more about [navigating history](/components/navigating-history).

### View past snaps

The workspace UI features a dropdown list of the component version history. You can pick any of the past versions and explore all the changes that happened in that version. This works like having a time-machine for your components.

<Image alt="version picker" src={versionPicker} />

### Comparing with past snaps

You may compare the current state of a component with past snap or version. To do so, run:

```bash
bit diff ui/my-welcome 1.0.0
```

### Version Affected Components

Bit understands the dependency graph of all components in a workspace. When tagging a component, it will also tag all components that are affected by the change. This means that you not only make sure all dependents get updated, you also do it in the most efficient way possible where the minimal amount of code gets rebuilt.  
Dependent components will get promoted by a semantic patch version.
