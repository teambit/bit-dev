import { Image } from '@teambit/docs.ui.zoomable-image';
import wsScreenshot from './ws-screenshot.png';
import workspaces from './workspaces.png';
import multiRepo from './multi-repo.png';

# Workspace Overview

A Bit Workspace is where you build [Components](/components/component-overview) and compose them into services and apps. 

Workspaces are usually source-controlled as "standard projects" using SCMs like git. However, once a Component in that Workspace is versioned and exported to a Remote Scope, it is no longer coupled to it in any way.
In that sense, a Workspace is best thought of as a temporary hub where Components are maintained, composed into more complex Components, and exported again.

<Image src={workspaces} style={{maxWidth: 800}} />

To get started with a demo Workspace, run the following command:

```bash
bit new react demo
```

## Component development server

Components in your workspace are displayed in the Workspace UI which is served by Bit's dev server. To start it, run the following command:

```sh
bit start
```

<Image src={wsScreenshot} width="80%"/>

## Simple, scalable dev experience

Keeping a similar dev-experience across workspaces allows you to jump in and out of codebases. You don't need to learn each project's dev setup, workflows, or specific commands.

Simple dev experience means you can **easily onboard** yourself to a workspace, thanks to:

- **Use the same commands** - Regardless of the tooling and configs used in a workspace, you use the same commands (`compile`, `test`, etc) and get similarly structured outputs.
- **Minimal configuration** - Most of the configuration and setup is automated. No need to define per-component dependencies and no additional files needed to change a component's build pipeline.
- **Templates and standards** - Create new components with templates and apply your formatting, linting, compilation and testing standards with a single policy.
- **Components are directories** - Each [component in your workspace is a directory](docs/workspace/component-directory) so relevant files, assets and tests available in a single place.

This makes it easy to scale the amount of components in a workspace, scale the amount of workspaces and even scale the amount of developers!

## Composition of components

A Workspace provides a monolith-like developer experience, and enables you to refactor many components in a single "project". In this "project", each component manages its own implementation, history and config.  
This allows you to be flexible with how you structure your Workspace. For example, you can [import a component](/docs/components/importing-components):

```bash
bit import teambit.community/ui/graph/bubble-graph
```

Bit adds the new component to the list of components in the workspace, pulls down the complete revision history, configs and dependencies. Now you're able to modify it locally, examine the component when running `bit start`, and maintain it as if that component was authored by you.

In the same sense you can `export` and even `eject` Components from a Workspace, and more it to another one. So if you started with building all components in the same place, you are not locked to that decision.

<Image src={multiRepo} width="85%"/>

## Personalize your workspace

With composability in mind you can personalize your workspace on a per-feature basis or on the work you are currently focus on. You can start your flow by using `bit import` and fetch all required components, starting to modify and work on them as needed.  
When done, you can version and eject unneeded components. Instead of you working in the boundaries of your workspace, have the workspace fit to your current work.

## Configuration-less

Regardless of the amount of components you have in your workspace, and how different they may be in their configuration, it only requires two files to manage components.

- `workspace.jsonc` - Contains the configuration policy for all components in the workspace.
- `.bitmap` - Maps Bit components to their corresponding location (dir) in the workspace.

With both these files you track where each component is located and can apply configuration from a centralized location according to various [`variant`](/docs/workspace/variants) rules. The workspace then calculates the configuration to apply on a per-component basis.

The end result is a clean workspace where you have a minimal amount of configuration files, no matter how many components you have and their variants.

## Any dev environment, any framework

Angular modules, React components, Node modules or any other type of components you might need are rendered with the same [workspace UI](docs/workspace/workspace-ui), compiled by the same `compile` command, etc.  
You can maintain components of different types and frameworks in a Bit workspace, as each component has it's own configured [Component Development Environment](/docs/envs/envs-overview), which the workspace use to run various workflows.

## Components in the workspace

A Bit Workspace manages many components. It aims to create symmetry between component naming and the directory structure.

```sh
├── cart
│   ├── purchase-summary
│   └── shopping-cart
└── design
    ├── ui
    │   ├── button
    │   └── card   // for example, the corresponding component ID: my-org.design/ui/button
    └── theme
        ├── color-pallet
        └── theme-context
```

:::tip The structure is not rigid. You can sort components however you see fit.
:::

For each component Bit generates a link in the root `node_modules` directory according to the component ID. It contains the compiled output of a component.

```bash
└── node_modules
    └── @my-org
        └── my-scope.ui.card
```

Use these modules when consuming one component in another, even in the same workspace.

```jsx
import { Card } from '@my-org/my-scope.ui.card';
```

:::info Absolute import statements decouple a component from the project's file structure.
:::

## Dependency Policy

The workspace dependency policy defines how external dependencies are installed and in which version. You may apply complex setups to have multiple versions of a dependency installed to fit different components. It allows you to determine where you want to adopt to a new version and which components should still use past versions.

In your workspace you also have a [dependency resolver](/docs/dependencies/dependencies-overview) that uses the policy to determine the type of dependency on a per-component basis.  
Types of dependencies, like `dependency` and `devDependency` are contextual for each component. Meaning that according to where a component `import`s a dependency, it will be set with the corresponding type. For example, a dependency only used in a test file will set as a `devDependency` for that specific component.

## Performance

Bit workspace is optimized for quick and snappy feedback loop on code changes. It leaves the tough work of ensuring de-coupling and isolation to a more robust CI flow.

To optimize performance even further any time you change a component Bit find which components are affected by the change. Bit then build your modified components and their affected dependents.

## Integrate to existing codebases

Bit is a build tool that allows you to manage independent components. You may create a Bit workspace in a fresh directory or initialize one as part of an existing repository.  
You can get started working on independent components alongside projects built with [Angular](https://angular.io/tutorial/toh-pt0), [CRA](https://create-react-app.dev) and even [Lerna](https://lerna.js.org).

`cd` to a pre-existing repository and run:

```bash
bit init
```

From here you may use any Bit command and flow to build independent components and integrate them into your application.
