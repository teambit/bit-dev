# Implement a Compiler

Standard compilers are integrated into Bit using a Bit Aspect. For example, [Babel](https://babeljs.io/) is integrated using the [Babel Aspect](https://bit.dev/teambit/compilation/babel) and [TypeScript](https://www.typescriptlang.org/) is integrated using the [TypeScript Aspect](https://bit.dev/teambit/typescript/typescript).
These Aspects implement the [Compiler interface](https://bit.dev/teambit/compilation/compiler/~code/types.ts). A compiler implementation should be able to provide [compilation in the workspace](./workspace-compilation) as well as [compilation during build](./compiling-during-build).

The easiest way to start implementing a [Compiler](/compiler/overview) is by using the 'compiler' template:

```bash title="Create a new Aspect component"
bit create compiler extensions/my-compiler
```

[See here](https://github.com/teambit/examples/tree/master/compilation/examples/extensions/my-compiler-no-sm) for an example of a compiler implementation.

## Implement Compilation in the Workspace

Workspace compilations is implemented by the [`transpileFile`](compiler-api#transpilefile) API (or, alternatively, by [`transpileComponent`](compiler-api#transpilecomponent)).
It receives the content of the component source files, one at a time, and returns the compiled output (content) to be handled by the Compiler aspect.

```ts
import babel from '@babel/core';
import { TranspileFileParams, TranspileFileOutput } from '@teambit/compiler';
// ...
export class MyCompilerNoSm implements Compiler {
  // ...
  transpileFile(fileContent: string, options: TranspileFileParams): TranspileFileOutput {
    const supportedExtensions = ['.ts', '.tsx', '.js', '.jsx'];
    const fileExtension = path.extname(options.filePath);
    if (!supportedExtensions.includes(fileExtension)) {
      return null; // file is not supported
    }
    if (!this.isFileSupported(options.filePath)) {
      return null; // file is not supported
    }
    const result = babel.transformSync(fileContent, { sourceMaps: true });
    if (!result) {
      return null;
    }
    const compiledCode = result.code || '';
    const outputPath = this.replaceFileExtToJs(options.filePath);
    const outputFiles = [{ outputText: compiledCode, outputPath }];

    return outputFiles; // output is used by the Compiler aspect
  }
}
```

## Implement Compilation during Build

Compilation during build is implemented by the [`build`](compiler-api#build) API. The `build` method is invoked (indirectly) by the Builder aspect, which passes to it the entire [Capsule Network](/docs/components/component-capsules#network) (`BuildContext`).
This data includes only the paths for the component source files, and not their content (unlike build in the workspace).

```ts
import babel from '@babel/core';
import { BuildContext, BuiltTaskResult, ComponentResult } from '@teambit/builder';
import { Capsule } from '@teambit/isolator';
// ...
export class MyCompilerNoSm implements Compiler {
  // ...
  async build(context: BuildContext): Promise<BuiltTaskResult> {
    /* 'Seeder Capsules' are Component Capsules that are being built,
     * not their dependencies.
     * There could be cases where the component dependencies should affect its compilation,
     * but not in this case.
     */
    const capsules = context.capsuleNetwork.seedersCapsules;
    const componentsResults: ComponentResult[] = [];
    await Promise.all(
      capsules.map(async (capsule) => {
        const currentComponentResult: ComponentResult = {
          errors: [],
          component: capsule.component,
        };
        await this.buildOneCapsule(capsule, currentComponentResult);
        componentsResults.push({ ...currentComponentResult });
      })
    );

    return {
      /* Sets the files to persist as the Component's artifacts,
       and describes them. */
      artifacts: [
        {
          generatedBy: this.id,
          name: 'compiler output',
          globPatterns: [`${this.distDir}/**`],
        },
      ],
      componentsResults,
    };
  }

  private async buildOneCapsule(capsule: Capsule, componentResult: ComponentResult) {
    const sourceFiles = capsule.component.filesystem.files.map((file) => file.relative);
    await fs.ensureDir(path.join(capsule.path, this.distDir));
    await Promise.all(
      sourceFiles.map(async (filePath) => {
        const absoluteFilePath = path.join(capsule.path, filePath);
        try {
          // here we use the transpileFilePathAsync API and not the transformSync because we don't have the file content
          // only the file paths in the capsules.
          const result = await this.transpileFilePathAsync(absoluteFilePath, babel);
          if (!result || !result.length) {
            // component files might be ignored by Babel, e.g. scss component.
            return;
          }
          const distPath = this.replaceFileExtToJs(filePath);
          await fs.outputFile(path.join(capsule.path, this.distDir, distPath), result[0].outputText);
        } catch (err: any) {
          componentResult.errors?.push(err);
        }
      })
    );
  }
}
```

It is recommended to expose an API that returns you compiler's build task, for Envs to use. Without it, Envs will be forced to use the Compiler aspect directly.

```ts
import { CompilerMain } from '@teambit/compiler';
// ...
export class MyCompilerNoSm implements Compiler {
  constructor(private compiler: CompilerMain) {}
  createTask() {
    return this.compiler.createTask('MyCompiler', this);
  }
}
```

## Expose which Files are Supported by your Compiler

Implement the [`isFileSupported`](compiler-api#isfilesupported) API to share with other aspects the file types supported by you compiler.
For example, the Compiler aspect uses this API to copy to the `dist` directory, files that will not be compiled (unsupported files).

```ts
export class MyCompilerNoSm implements Compiler {
  // ...
  isFileSupported(filePath: string): boolean {
    return (
      filePath.endsWith('.ts') || filePath.endsWith('.tsx') || filePath.endsWith('.js') || filePath.endsWith('.jsx')
    );
  }
}
```

## Expose your Compiler's Output Paths

Implement the [`getDistPathBySrcPath`](compiler-api#getdistpathbysrcpath) API to share with other aspects the dist paths.

```ts
export class MyCompilerNoSm implements Compiler {
  // ...
  distDir = 'dist';

  getDistPathBySrcPath(srcPath: string) {
    const fileWithJSExtIfNeeded = this.replaceFileExtToJs(srcPath);
    return path.join(this.distDir, fileWithJSExtIfNeeded);
  }

  private replaceFileExtToJs(filePath: string): string {
    // see 'isFileSupported' in previous section
    if (!this.isFileSupported(filePath)) return filePath;
    const fileExtension = path.extname(filePath);
    return filePath.replace(new RegExp(`${fileExtension}$`), '.js');
  }
}
```

## Expose a 'CreateCompiler' API for Envs to Use

Update the compiler's main runtime file (`my-compiler.main.runtime.ts`) to do the following:

1. Expose the `createCompiler` API for Envs to use.

2. Update the main file property of the component's `package.json`, via the `getPackageJsonProps` service handler.

```ts
import { MainRuntime } from '@teambit/cli';
import { CompilerAspect, CompilerMain } from '@teambit/compiler';
import { MyCompilerNoSm } from './my-compiler.compiler';
import { MyCompilerNoSmAspect } from './my-compiler.aspect';

export class MyCompilerMain {
  constructor(private compiler: CompilerMain) {}

  static dependencies = [CompilerAspect];

  static runtime = MainRuntime;

  createCompiler(): MyCompilerNoSm {
    return new MyCompiler(MyCompilerAspect.id, this.compiler);
  }

  getPackageJsonProps() {
    return {
      main: 'dist/{main}.js',
    };
  }

  static async provider([compiler]: [CompilerMain]) {
    return new MyCompiler(compiler);
  }
}

MyCompilerNoSmAspect.addRuntime(MyCompilerMain);
```

## Using the Compiler Implementation in an Env

[See here](configure-env-with-compiler) to learn how to configure you Env to use your compiler implementation.
