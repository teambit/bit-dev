# Extending an env

Envs are customizable and extendable. This means that instead of starting from scratch, you take an existing env and compose your workflow and configs using it. The base env will be a dependency for yours, so you can start iterating on the specific settings you need. The scope of changes and complexity is up to you: adding a single lint rule, changing the build pipeline or even adding a completely new workflow, and anything is between is possible.

Your custom env will be versioned and managed just like any other component, allowing you a single-point of control for how components are managed.

Envs provide templates to get started quickly with composing on top of them. To see list of available templates:

```bash
bit templates
```

Let's create a basic env that composes one of the base envs:

```bash
bit create react-env envs/my-env
```

The template generates the following component:

```bash
scope/my-env
├── index.ts
├── jest
│   └── jest.config.js
├── my-env.aspect.ts
├── my-env.docs.mdx
├── my-env.main.runtime.ts
├── my-env.preview.runtime.ts
├── typescript
│   └── tsconfig.json
└── webpack
    └── webpack-transformers.ts
```

To get started with your local env, you first need to configure it as an [aspect](/docs/extending-bit/aspect-overview) using the `teambit.harmony/aspect` env. Once this is set, you can apply the env you now have in your workspace to be applied on any component.  
Both tasks are handled by configuring `workspace.jsonc` file:

```javascript
{
  "teambit.workspace/variants": {
    "envs/my-env": {
      "teambit.harmony/aspect": {}
    },
    "{pages/**}": {
      "company.scope/envs/my-env": {}
    }
  }
}
```

Validate the configuration by running `env`:

```bash
bit env
```

```bash
┌──────────────────────────────────┬─────────────────────────────────┐
│ component                        │ env                             │
├──────────────────────────────────┼─────────────────────────────────┤
│ company.scope/envs/my-env        │ teambit.harmony/aspect          │
├──────────────────────────────────┼─────────────────────────────────┤
│ company.scope/pages/welcome      │ company.scope/envs/my-env       │
└──────────────────────────────────┴─────────────────────────────────┘
```

Now when you run `compile` and any other command, the component `company.scope/pages/welcome` will use the configuration from `company.scope/envs/my-env`.

Get started with optimizing your flow by editing `*.main.ts`:

```javascript
import { MainRuntime } from '@teambit/cli';
import { ReactAspect, ReactMain } from '@teambit/react'; // Set a dependency on the env to extend
import { EnvsAspect, EnvsMain } from '@teambit/envs';
import { MyReactAspect } from './my-react.aspect';

export class MyReactMain {
  static slots = [];
  static dependencies = [ReactAspect, EnvsAspect];
  static runtime = MainRuntime;

  static async provider([react, envs]: [ReactMain, EnvsMain]) {
    const templatesReactEnv = envs.compose(react.reactEnv, [
      react.useTypescript( ),     // an API from the base env to change the functionality of the typescript compiler
      react.useEslint( ),         // an API from the base env to change the functionality of the eslint linter
    ]);
    envs.registerEnv(templatesReactEnv); // register the composed env
    return new MyReactMain();
  }
}

MyReactAspect.addRuntime(MyReactMain);
```

Once you apply any change, you can `tag` the first version of your component and export it.

```bash
bit tag company.scope/envs/my-env --message "first version"
bit export
```

Using a customized env works just the same as any other env. In any Bit workspace open the `workspace.jsonc` file and apply your env via `variants`:

```javascript
{
  "teambit.workspace/variants": {
    "{pages/**}": {
      "company.scope/envs/my-env": {}
    }
  }
}
```
