import { Image } from '@teambit/docs.ui.zoomable-image';
import compilerDiagram from './compiler-diagram.png';

# Env Services Overview

Dev Services simplify and standardize component development processes, like testing, linting and documenting. They are applied on components via [Envs](/envs/overview).

Standardized development means you can use the same commands and APIs to operate different services of the same category. These services will produce outputs that have a standardized format, and that generate similar effects in the [Workspace](/workspace/workspace-overview) or [Capsule](/dev-services-overview/builder/capsule).

For instance, `bit compile` will compile all components in your workspace, regardless of the specific tool (TS, Babel, etc.) used by each component.
The output to the CLI will have the same format, and the generated dist files will all be available in the components' corresponding `node_modules` directory.


## Execution in the workspace VS Execution during build

Dev Services can be used in the workspace, during development, or in the capsule, during the component build. When used during a build that runs as part of the `tag` or `snap` processes, Dev Services often persist output data in the component metadata and artifacts.

For example, Compiler persists compilation results in the component metadata, and adds the dist files to the component artifacts.

Development and build processes are often configured differently to address the needs of each context.

For example, the TypeScript Aspect does not generate `.d.ts` files when used in the workspace (during development) but does generate these files when used during component build. This is done in order to improve performance during development.


## Service Handlers

Service Handlers are the link that binds an Env to a Dev Service. These are methods that are implemented in the Env class, and invoked by their corresponding Env Service.

For example, the 'MyEnv' Env, shown below, uses the Service Handler `getCompiler()` which returns the specific tool and config, to use for compilation (in that case, the Babel Aspect).
The `getCompiler()` method will be invoked by Compiler Aspect (the compiler dev service).

```ts 
import { CompilerEnv} from '@teambit/envs';
import { babelConfig } './babel-config';

export class MyReactEnv implements CompilerEnv  {

  getCompiler() {
    return this.babel.createCompiler(babelConfig);
  }

}
```

Environment services run on various events. Whenever a service runs, it executes its corresponding service handler which consequently runs the configured Dev service implementation (in that example, that would be the Babel Aspect).

Different components in a Bit workspace may use different environments. That means dev services need to execute their corresponding service handlers in the specific environment applied on the component currently being processed.

For example, if _component A_ uses the Node environment then the Compiler service processing that component files, will execute the Service Handler (in that case, `getCompiler`) found in the Node environment.

An Env can be customized by replacing its service handlers, or by adding new ones (learn more in the specific dev service you'd like to replace or add. For example: ['Replace an Env's compiler'](/dev-services-overview/compiler/using-a-compiler#replace-an-env's-compiler-using-an-env-extension)).

## Implementing a Dev Service

As mentioned above, Dev Services are standardizers of certain types of development workflows. Looking at it from the perspective of a dev tool maintainer, dev services simplify the integration of tools into Bit by offering an abstraction layer, between your tool and all the required Aspects.

<Image src={compilerDiagram} style={{maxWidth: 700} }/>

For example, the following compiler implements the Compiler interface, to integrate [Babel](https://jestjs.io/) into Bit, _as a compiler_.
Using the Dev Service API, the Babel Aspect is able to access and use all the relevant Aspects, and use them in a way that is consistent with other Aspects that serve as compilers.

```ts
// ...
import * as babel from '@babel/core';
import { ... } from '@teambit/compiler';
import path from 'path';

export class BabelCompiler implements Compiler {

  transpileFile(
    fileContent: string,
    options: TranspileFileParams
  ): TranspileFileOutput {
    const result = babel.transformSync(fileContent);
    // ...
    return [{ outputText: compiledContent, outputPath: compiledFilename }];
  }
  // ...
}
```