import { Image } from '@teambit/docs.ui.zoomable-image';
import devServiceDiagram from './dev-services-diagram.png';
import devServiceAPIImg from './dev-service-api.png';

# Environment Services

[Environments](/docs/environments/envs-overview) run various commands and workflows on components, such as compilation, testing and linting. These workflows are implemented in a set of internal tools called **Environment Services**, which may use other tools to accomplish a wanted task.

Use Dev Services to customize workflows by adding or modifying support for tools. For example, could supply an env-service to extend your current workflow or add an entirely new command.

<img src={devServiceDiagram} style={{ maxHeight:'240px' }} />

The same env-service can be used in several environments, as the environment provides it with the necessary context and configuration to run the command of workflow.

## Implementing an Environment Service

Env-services are [Bit Aspect](/docs/extending-bit/aspect-overview) that among other things, implements the `EnvService` interface.

<Image src={devServiceAPIImg} width="70%" />

For example, the [Babel Aspect](https://bit.dev/teambit/defender/jest) implements the Compiler interface, to integrate [Babel](https://jestjs.io/) into Bit, _as a compiler_.
Using the Dev Service API, the Babel Aspect is able to access and use all the relevant Aspects, and use them in a way that is consistent with other Aspects that serve as compilers.

```ts title="Example: The Babel Aspect implements the Compiler interface"
// Example: The Babel Aspect implements the Compiler interface

import { Compiler } from '@teambit/compiler';
import * as babel from '@babel/core';

export class BabelCompiler implements Compiler {
  constructor(
    // ...
    private babelModule = babel;
  ){}
  // ...

  // 'version()'' is part of the Compiler interface.
  // It enables Compiler to get access to the compiler version.

  version() {
    return this.babelModule.version;
  }
}
```



## Abstract Away your Tooling


While the landscape of tooling is ever-changing, however they generally manage and provide specific **services** to the developer. For example, while you can choose which tool(s) you want to use for writing and running tests, all tools in the testing eco-system provide a common set of services for validating code and providing insights on it.

## Service

service is an aspect that implements a `envs/envs/service.ts`

The internal

## Service Handlers

Service Handler is an API the Env Service implements for any Environment that wants to use it. The API may support passing configuration, tools, or anything needed by the env-service.

Service Handlers are the link that binds an Env to a Dev Service. These are methods that are implemented the Env class, and invoked by their corresponding Env Service.

For example, the 'MyReactEnv' Env, shown above, uses the Service Handler `getCompiler()` to configure the Compiler Env Service to run the Babel aspect. The `getCompiler()` method is expected to be found by the Compiler, which will invoke it

Environment services run on various events. Whenever a service runs, it executes its corresponding service handler which consequently runs the configured Dev service implementation (in that example, that would be the Babel Aspect).

Different components in a Bit workspace may use different environments. That means environment services need to execute their corresponding service handlers in the specific environment applied on the component currently being processed.

For example, if _component A_ uses the Node environment then the Compiler service processing that component files, will execute the Service Handler (in that case, `getCompiler`) found in the Node environment.


## Execution in the workspace VS Execution during build

Dev Services can be used in the workspace, during development, or in the capsule, during the component build. When used during a build that runs as part of the `tag` or `snap` processes, Dev Services often persist output data in the component metadata and artifacts.

For example, Compiler persists compilation results in the component metadata, and adds the dist files to the component artifacts.

Development and build processes are often configured differently to address the needs of each context.

For example, the TypeScript Aspect does not generate `.d.ts` files when used in the workspace (during development) but does generate these files when used during component build. This is done in order to improve performance during development.
